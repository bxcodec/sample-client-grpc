// Code generated by protoc-gen-go. DO NOT EDIT.
// source: article.proto

/*
Package article is a generated protocol buffer package.

It is generated from these files:
	article.proto

It has these top-level messages:
	ErrorMessage
	BatchInsertResponse
	ListArticle
	DeleteResponse
	FetchRequest
	SingleRequest
	Article
*/
package article

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ErrorMessage struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *ErrorMessage) Reset()                    { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string            { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()               {}
func (*ErrorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ErrorMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type BatchInsertResponse struct {
	TotalSuccess int64           `protobuf:"varint,1,opt,name=TotalSuccess" json:"TotalSuccess,omitempty"`
	Errors       []*ErrorMessage `protobuf:"bytes,2,rep,name=Errors" json:"Errors,omitempty"`
}

func (m *BatchInsertResponse) Reset()                    { *m = BatchInsertResponse{} }
func (m *BatchInsertResponse) String() string            { return proto.CompactTextString(m) }
func (*BatchInsertResponse) ProtoMessage()               {}
func (*BatchInsertResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *BatchInsertResponse) GetTotalSuccess() int64 {
	if m != nil {
		return m.TotalSuccess
	}
	return 0
}

func (m *BatchInsertResponse) GetErrors() []*ErrorMessage {
	if m != nil {
		return m.Errors
	}
	return nil
}

type ListArticle struct {
	Artilces []*Article `protobuf:"bytes,1,rep,name=Artilces" json:"Artilces,omitempty"`
	Cursor   string     `protobuf:"bytes,2,opt,name=Cursor" json:"Cursor,omitempty"`
}

func (m *ListArticle) Reset()                    { *m = ListArticle{} }
func (m *ListArticle) String() string            { return proto.CompactTextString(m) }
func (*ListArticle) ProtoMessage()               {}
func (*ListArticle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListArticle) GetArtilces() []*Article {
	if m != nil {
		return m.Artilces
	}
	return nil
}

func (m *ListArticle) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

type DeleteResponse struct {
	Status string `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Code   int32  `protobuf:"varint,2,opt,name=code" json:"code,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DeleteResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *DeleteResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type FetchRequest struct {
	Num    int64  `protobuf:"varint,1,opt,name=num" json:"num,omitempty"`
	Cursor string `protobuf:"bytes,2,opt,name=cursor" json:"cursor,omitempty"`
}

func (m *FetchRequest) Reset()                    { *m = FetchRequest{} }
func (m *FetchRequest) String() string            { return proto.CompactTextString(m) }
func (*FetchRequest) ProtoMessage()               {}
func (*FetchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FetchRequest) GetNum() int64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *FetchRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

type SingleRequest struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *SingleRequest) Reset()                    { *m = SingleRequest{} }
func (m *SingleRequest) String() string            { return proto.CompactTextString(m) }
func (*SingleRequest) ProtoMessage()               {}
func (*SingleRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SingleRequest) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Article struct {
	ID        int64                      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Title     string                     `protobuf:"bytes,2,opt,name=Title" json:"Title,omitempty"`
	Content   string                     `protobuf:"bytes,3,opt,name=Content" json:"Content,omitempty"`
	UpdatedAt *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=UpdatedAt" json:"UpdatedAt,omitempty"`
	CreatedAt *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
}

func (m *Article) Reset()                    { *m = Article{} }
func (m *Article) String() string            { return proto.CompactTextString(m) }
func (*Article) ProtoMessage()               {}
func (*Article) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Article) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Article) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Article) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Article) GetUpdatedAt() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *Article) GetCreatedAt() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func init() {
	proto.RegisterType((*ErrorMessage)(nil), "article.ErrorMessage")
	proto.RegisterType((*BatchInsertResponse)(nil), "article.BatchInsertResponse")
	proto.RegisterType((*ListArticle)(nil), "article.ListArticle")
	proto.RegisterType((*DeleteResponse)(nil), "article.DeleteResponse")
	proto.RegisterType((*FetchRequest)(nil), "article.FetchRequest")
	proto.RegisterType((*SingleRequest)(nil), "article.SingleRequest")
	proto.RegisterType((*Article)(nil), "article.Article")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ArticleHandler service

type ArticleHandlerClient interface {
	GetArticle(ctx context.Context, in *SingleRequest, opts ...grpc.CallOption) (*Article, error)
	FetchArticle(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (ArticleHandler_FetchArticleClient, error)
	BatchInsert(ctx context.Context, opts ...grpc.CallOption) (ArticleHandler_BatchInsertClient, error)
	BatchUpdate(ctx context.Context, opts ...grpc.CallOption) (ArticleHandler_BatchUpdateClient, error)
	GetListArticle(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*ListArticle, error)
	UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error)
	Delete(ctx context.Context, in *SingleRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	Store(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error)
}

type articleHandlerClient struct {
	cc *grpc.ClientConn
}

func NewArticleHandlerClient(cc *grpc.ClientConn) ArticleHandlerClient {
	return &articleHandlerClient{cc}
}

func (c *articleHandlerClient) GetArticle(ctx context.Context, in *SingleRequest, opts ...grpc.CallOption) (*Article, error) {
	out := new(Article)
	err := grpc.Invoke(ctx, "/article.ArticleHandler/GetArticle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleHandlerClient) FetchArticle(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (ArticleHandler_FetchArticleClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArticleHandler_serviceDesc.Streams[0], c.cc, "/article.ArticleHandler/FetchArticle", opts...)
	if err != nil {
		return nil, err
	}
	x := &articleHandlerFetchArticleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArticleHandler_FetchArticleClient interface {
	Recv() (*Article, error)
	grpc.ClientStream
}

type articleHandlerFetchArticleClient struct {
	grpc.ClientStream
}

func (x *articleHandlerFetchArticleClient) Recv() (*Article, error) {
	m := new(Article)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *articleHandlerClient) BatchInsert(ctx context.Context, opts ...grpc.CallOption) (ArticleHandler_BatchInsertClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArticleHandler_serviceDesc.Streams[1], c.cc, "/article.ArticleHandler/BatchInsert", opts...)
	if err != nil {
		return nil, err
	}
	x := &articleHandlerBatchInsertClient{stream}
	return x, nil
}

type ArticleHandler_BatchInsertClient interface {
	Send(*Article) error
	CloseAndRecv() (*BatchInsertResponse, error)
	grpc.ClientStream
}

type articleHandlerBatchInsertClient struct {
	grpc.ClientStream
}

func (x *articleHandlerBatchInsertClient) Send(m *Article) error {
	return x.ClientStream.SendMsg(m)
}

func (x *articleHandlerBatchInsertClient) CloseAndRecv() (*BatchInsertResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(BatchInsertResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *articleHandlerClient) BatchUpdate(ctx context.Context, opts ...grpc.CallOption) (ArticleHandler_BatchUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArticleHandler_serviceDesc.Streams[2], c.cc, "/article.ArticleHandler/BatchUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &articleHandlerBatchUpdateClient{stream}
	return x, nil
}

type ArticleHandler_BatchUpdateClient interface {
	Send(*Article) error
	Recv() (*Article, error)
	grpc.ClientStream
}

type articleHandlerBatchUpdateClient struct {
	grpc.ClientStream
}

func (x *articleHandlerBatchUpdateClient) Send(m *Article) error {
	return x.ClientStream.SendMsg(m)
}

func (x *articleHandlerBatchUpdateClient) Recv() (*Article, error) {
	m := new(Article)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *articleHandlerClient) GetListArticle(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*ListArticle, error) {
	out := new(ListArticle)
	err := grpc.Invoke(ctx, "/article.ArticleHandler/GetListArticle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleHandlerClient) UpdateArticle(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error) {
	out := new(Article)
	err := grpc.Invoke(ctx, "/article.ArticleHandler/UpdateArticle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleHandlerClient) Delete(ctx context.Context, in *SingleRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/article.ArticleHandler/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *articleHandlerClient) Store(ctx context.Context, in *Article, opts ...grpc.CallOption) (*Article, error) {
	out := new(Article)
	err := grpc.Invoke(ctx, "/article.ArticleHandler/Store", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ArticleHandler service

type ArticleHandlerServer interface {
	GetArticle(context.Context, *SingleRequest) (*Article, error)
	FetchArticle(*FetchRequest, ArticleHandler_FetchArticleServer) error
	BatchInsert(ArticleHandler_BatchInsertServer) error
	BatchUpdate(ArticleHandler_BatchUpdateServer) error
	GetListArticle(context.Context, *FetchRequest) (*ListArticle, error)
	UpdateArticle(context.Context, *Article) (*Article, error)
	Delete(context.Context, *SingleRequest) (*DeleteResponse, error)
	Store(context.Context, *Article) (*Article, error)
}

func RegisterArticleHandlerServer(s *grpc.Server, srv ArticleHandlerServer) {
	s.RegisterService(&_ArticleHandler_serviceDesc, srv)
}

func _ArticleHandler_GetArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleHandlerServer).GetArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/article.ArticleHandler/GetArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleHandlerServer).GetArticle(ctx, req.(*SingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleHandler_FetchArticle_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FetchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArticleHandlerServer).FetchArticle(m, &articleHandlerFetchArticleServer{stream})
}

type ArticleHandler_FetchArticleServer interface {
	Send(*Article) error
	grpc.ServerStream
}

type articleHandlerFetchArticleServer struct {
	grpc.ServerStream
}

func (x *articleHandlerFetchArticleServer) Send(m *Article) error {
	return x.ServerStream.SendMsg(m)
}

func _ArticleHandler_BatchInsert_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArticleHandlerServer).BatchInsert(&articleHandlerBatchInsertServer{stream})
}

type ArticleHandler_BatchInsertServer interface {
	SendAndClose(*BatchInsertResponse) error
	Recv() (*Article, error)
	grpc.ServerStream
}

type articleHandlerBatchInsertServer struct {
	grpc.ServerStream
}

func (x *articleHandlerBatchInsertServer) SendAndClose(m *BatchInsertResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *articleHandlerBatchInsertServer) Recv() (*Article, error) {
	m := new(Article)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ArticleHandler_BatchUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArticleHandlerServer).BatchUpdate(&articleHandlerBatchUpdateServer{stream})
}

type ArticleHandler_BatchUpdateServer interface {
	Send(*Article) error
	Recv() (*Article, error)
	grpc.ServerStream
}

type articleHandlerBatchUpdateServer struct {
	grpc.ServerStream
}

func (x *articleHandlerBatchUpdateServer) Send(m *Article) error {
	return x.ServerStream.SendMsg(m)
}

func (x *articleHandlerBatchUpdateServer) Recv() (*Article, error) {
	m := new(Article)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ArticleHandler_GetListArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleHandlerServer).GetListArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/article.ArticleHandler/GetListArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleHandlerServer).GetListArticle(ctx, req.(*FetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleHandler_UpdateArticle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleHandlerServer).UpdateArticle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/article.ArticleHandler/UpdateArticle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleHandlerServer).UpdateArticle(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleHandler_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SingleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleHandlerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/article.ArticleHandler/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleHandlerServer).Delete(ctx, req.(*SingleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArticleHandler_Store_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Article)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArticleHandlerServer).Store(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/article.ArticleHandler/Store",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArticleHandlerServer).Store(ctx, req.(*Article))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArticleHandler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "article.ArticleHandler",
	HandlerType: (*ArticleHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetArticle",
			Handler:    _ArticleHandler_GetArticle_Handler,
		},
		{
			MethodName: "GetListArticle",
			Handler:    _ArticleHandler_GetListArticle_Handler,
		},
		{
			MethodName: "UpdateArticle",
			Handler:    _ArticleHandler_UpdateArticle_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ArticleHandler_Delete_Handler,
		},
		{
			MethodName: "Store",
			Handler:    _ArticleHandler_Store_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FetchArticle",
			Handler:       _ArticleHandler_FetchArticle_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BatchInsert",
			Handler:       _ArticleHandler_BatchInsert_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchUpdate",
			Handler:       _ArticleHandler_BatchUpdate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "article.proto",
}

func init() { proto.RegisterFile("article.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0x51, 0x6e, 0xd3, 0x40,
	0x10, 0x95, 0xed, 0xc6, 0xa1, 0x93, 0xc4, 0xaa, 0x96, 0x12, 0xac, 0x08, 0xa9, 0x91, 0xbf, 0x2c,
	0x01, 0x6e, 0x95, 0x0a, 0xd4, 0x4a, 0x20, 0x54, 0x12, 0x28, 0x91, 0xe0, 0xc7, 0x09, 0x07, 0x70,
	0xed, 0x21, 0xb1, 0xe4, 0x78, 0xc3, 0xee, 0xf8, 0x78, 0x9c, 0x83, 0xeb, 0x20, 0x7b, 0xd7, 0xae,
	0x43, 0x5a, 0x35, 0x7f, 0xf3, 0x66, 0xdf, 0x9b, 0x99, 0x9d, 0x79, 0x30, 0x88, 0x04, 0xa5, 0x71,
	0x86, 0xc1, 0x56, 0x70, 0xe2, 0xac, 0xab, 0xe1, 0xe8, 0x6c, 0xc5, 0xf9, 0x2a, 0xc3, 0xf3, 0x2a,
	0x7d, 0x57, 0xfc, 0x3a, 0xa7, 0x74, 0x83, 0x92, 0xa2, 0xcd, 0x56, 0x31, 0x3d, 0x1f, 0xfa, 0x5f,
	0x84, 0xe0, 0xe2, 0x07, 0x4a, 0x19, 0xad, 0x90, 0xb9, 0xd0, 0xdd, 0xa8, 0xd0, 0x35, 0xc6, 0x86,
	0x7f, 0x1c, 0xd6, 0xd0, 0x5b, 0xc3, 0xf3, 0xcf, 0x11, 0xc5, 0xeb, 0x79, 0x2e, 0x51, 0x50, 0x88,
	0x72, 0xcb, 0x73, 0x89, 0xcc, 0x83, 0xfe, 0x92, 0x53, 0x94, 0x2d, 0x8a, 0x38, 0x46, 0x29, 0x2b,
	0x95, 0x15, 0xee, 0xe4, 0xd8, 0x5b, 0xb0, 0xab, 0x26, 0xd2, 0x35, 0xc7, 0x96, 0xdf, 0x9b, 0xbc,
	0x08, 0xea, 0x71, 0xdb, 0xbd, 0x43, 0x4d, 0xf2, 0x16, 0xd0, 0xfb, 0x9e, 0x4a, 0xba, 0x51, 0x1c,
	0xf6, 0x06, 0x9e, 0x95, 0x61, 0x16, 0x63, 0x59, 0xbd, 0xd4, 0x9f, 0x34, 0x7a, 0xcd, 0x09, 0x1b,
	0x06, 0x1b, 0x82, 0x3d, 0x2d, 0x84, 0xe4, 0xc2, 0x35, 0xab, 0xf9, 0x35, 0xf2, 0x3e, 0x80, 0x33,
	0xc3, 0x0c, 0x09, 0x9b, 0xc9, 0x87, 0x60, 0x4b, 0x8a, 0xa8, 0x90, 0xfa, 0xa7, 0x1a, 0x31, 0x06,
	0x47, 0x31, 0x4f, 0xb0, 0xd2, 0x77, 0xc2, 0x2a, 0xf6, 0xae, 0xa0, 0xff, 0x15, 0x29, 0x5e, 0x87,
	0xf8, 0xbb, 0x40, 0x49, 0xec, 0x04, 0xac, 0xbc, 0xd8, 0xe8, 0xcf, 0x96, 0x61, 0x59, 0x2d, 0xde,
	0xe9, 0xab, 0x90, 0x77, 0x06, 0x83, 0x45, 0x9a, 0xaf, 0x32, 0xac, 0xa5, 0x0e, 0x98, 0x69, 0xa2,
	0x95, 0x66, 0x9a, 0x78, 0x7f, 0x0c, 0xe8, 0xd6, 0x5f, 0x75, 0xc0, 0x9c, 0xcf, 0xea, 0xb7, 0xf9,
	0x8c, 0x9d, 0x42, 0x67, 0x99, 0x52, 0x86, 0xba, 0xa6, 0x02, 0xe5, 0x8d, 0xa6, 0x3c, 0x27, 0xcc,
	0xc9, 0xb5, 0xd4, 0x8d, 0x34, 0x64, 0x57, 0x70, 0xfc, 0x73, 0x9b, 0x44, 0x84, 0xc9, 0x0d, 0xb9,
	0x47, 0x63, 0xc3, 0xef, 0x4d, 0x46, 0x81, 0xb2, 0x40, 0x50, 0x5b, 0x20, 0x58, 0xd6, 0x16, 0x08,
	0xef, 0xc9, 0xa5, 0x72, 0x2a, 0x50, 0x2b, 0x3b, 0x4f, 0x2b, 0x1b, 0xf2, 0xe4, 0xaf, 0x05, 0x8e,
	0x9e, 0xff, 0x5b, 0x94, 0x27, 0x19, 0x0a, 0xf6, 0x1e, 0xe0, 0x16, 0x9b, 0xfb, 0x0d, 0x9b, 0x6b,
	0xed, 0x2c, 0x62, 0xb4, 0x77, 0x45, 0x76, 0xad, 0xb7, 0x5c, 0xe3, 0x7b, 0x9f, 0xb4, 0x97, 0xbf,
	0x2f, 0xbc, 0x30, 0xd8, 0x27, 0xe8, 0xb5, 0xdc, 0xc9, 0xf6, 0x28, 0xa3, 0x57, 0x4d, 0xe6, 0x01,
	0x17, 0xfb, 0x06, 0x7b, 0xa7, 0x0b, 0xa8, 0x95, 0x3c, 0x50, 0x60, 0x2f, 0xe3, 0x1b, 0x17, 0x06,
	0xfb, 0x08, 0xce, 0x2d, 0x52, 0xdb, 0xae, 0x8f, 0x0c, 0x7d, 0xda, 0xa4, 0xdb, 0xe4, 0x4b, 0x18,
	0xa8, 0x86, 0x75, 0xe2, 0x80, 0xbe, 0xec, 0x1a, 0x6c, 0x65, 0xe5, 0x47, 0x57, 0xfb, 0xb2, 0xc9,
	0xff, 0xe7, 0xf9, 0xd7, 0xd0, 0x59, 0x10, 0x17, 0x07, 0xf5, 0xb9, 0xb3, 0xab, 0xc3, 0x5f, 0xfe,
	0x0b, 0x00, 0x00, 0xff, 0xff, 0xba, 0xfb, 0x1a, 0x03, 0x5d, 0x04, 0x00, 0x00,
}
